1. Титулна страница – 1 стр.
2. Съдържание – 1 стр.
3. Увод (въведение) – 1 стр.
Кратко представяне на темата

Цели на дипломния проект

Очаквани резултати

4. Основна част – общо около 22–24 стр., включва:
4.1. Django – кратък преглед на фреймуърка – 2 стр.
Какво е Django

Архитектура и структура на едно Django приложение

4.2. Django Forms – 5 стр.
Какво представляват Django Forms

Създаване и използване на обикновени форми

Свързване на форми с изгледи и шаблони

4.3. ModelForms – 4 стр.
Създаване на ModelForm на база на модел

Автоматично генериране на полета

Разлика между Forms и ModelForms

4.4. Валидиране на данни – 4 стр.
Вградена валидация

Писане на собствени валидатори

Обработка на грешки във формите

4.5. Интегриране на форми в уеб приложение – 2 стр.
Използване на Django templates

Работа с POST заявки

Преглед на lifecycle на формата

4.6. Анализ на съществуващи решения (други фреймуърци или библиотеки) – 2 стр.
4.7. Избор на технологии и аргументация – 2 стр.
Защо е избран Django

Защо формите са подходящи за онлайн магазин

4.8. Приноси на проекта – 1–2 стр.
Какво е постигнато

Какви проблеми са решени

5. Заключение – 1–2 стр.
Изводи от разработката

Предложения за бъдещо развитие

6. Списък на използвана литература – 1 стр.
По азбучен ред, с цитирани източници

7. Приложения – 2–3 стр.
Извадки от кода

Скрийншоти от работещата форма и интерфейс

Диаграми, ако има


Django Forms
Въведение
Една от най-мощните и полезни функционалности на Django е системата за работа с форми. Django Forms предоставя структуриран и сигурен начин за събиране, обработка и валидиране на входни данни от потребителите. Вместо ръчно да се пише HTML код, да се проверява входът и да се изгражда логика за грешки, Django автоматизира по-голямата част от процеса. Това улеснява разработчиците и намалява риска от уязвимости.

Основни концепции
Формата в Django представлява Python клас, който дефинира полета, типове данни и методи за валидация. Django автоматично може да генерира HTML код, да обработва POST заявки и да визуализира съобщения за грешки.

Пример за обикновена форма:
///////


from django import forms

class ContactForm(forms.Form):
    name = forms.CharField(max_length=100)
    email = forms.EmailField()
    message = forms.CharField(widget=forms.Textarea)

///////
Тук се създава форма за контакт с три полета: име, имейл и съобщение. Django ще се погрижи за автоматичното им визуализиране и валидиране.

Използване на форми във view
След като формата е създадена, тя се използва във view функция, за да се обработват GET и POST заявки. Пример:

////

from django.shortcuts import render
from .forms import ContactForm

def contact_view(request):
    if request.method == 'POST':
        form = ContactForm(request.POST)
        if form.is_valid():
            # обработка на данните
            pass
    else:
        form = ContactForm()
    return render(request, 'contact.html', {'form': form})

//////
Рендиране на формата в шаблон
Формите могат да се рендират автоматично с помощта на Django шаблони:

<form method="post">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Изпрати</button>
</form>

//////

Методът {{ form.as_p }} визуализира формата като HTML с <p> тагове. Алтернативни методи са as_table() и as_ul().

Видове полета във форми
Django предлага голямо разнообразие от типове полета, в зависимост от типа на данните:

CharField – текстово поле

EmailField – имейл адрес

IntegerField – цели числа

BooleanField – чекбокс

ChoiceField – падащо меню

DateField – дата

FileField и ImageField – файлове и изображения

Пример за форма с избор:

class FeedbackForm(forms.Form):
    RATING_CHOICES = [
        ('1', 'Много лошо'),
        ('2', 'Лошо'),
        ('3', 'Средно'),
        ('4', 'Добро'),
        ('5', 'Отлично'),
    ]
    name = forms.CharField()
    rating = forms.ChoiceField(choices=RATING_CHOICES)


/////////

Персонализиране на формите
Освен автоматичното поведение, формите могат да бъдат персонализирани с помощта на параметри:

label – променя текста на етикета

initial – стойност по подразбиране

required – дали полето е задължително

widget – за избор на HTML елемент

Пример:

///////////


class CustomForm(forms.Form):
    username = forms.CharField(label='Потребителско име', max_length=30, required=True)
    password = forms.CharField(widget=forms.PasswordInput)

////////////


Валидация
Django автоматично валидира стойности според типа на полето. Освен това, могат да се добавят потребителски валидации с методите clean_<име на поле> или общия clean():

////////

class RegisterForm(forms.Form):
    username = forms.CharField()
    password = forms.CharField(widget=forms.PasswordInput)
    confirm_password = forms.CharField(widget=forms.PasswordInput)

    def clean(self):
        cleaned_data = super().clean()
        p1 = cleaned_data.get("password")
        p2 = cleaned_data.get("confirm_password")
        if p1 != p2:
            raise forms.ValidationError("Паролите не съвпадат.")

/////////////

Съобщения за грешки
Ако формата е невалидна, Django автоматично показва грешки до съответните полета. В шаблоните можем да визуализираме съобщенията с:

///////////

{% for field in form %}
  {{ field.label_tag }} {{ field }}
  {% for error in field.errors %}
    <div class="error">{{ error }}</div>
  {% endfor %}
{% endfor %}


/////////////

4.	MODELFORMS
4.1	ВЪВЕДЕНИЕ
В предходната точка разгледахме стандартните Django форми, които се изграждат ръчно чрез дефиниране на всяко поле. Django обаче предоставя още по-удобен начин за създаване на форми, когато те трябва да отразяват структурата на база данни – чрез ModelForms. ModelForm е клас във Django, който автоматично създава форма въз основа на вече дефиниран модел. Това спестява време, премахва дублиране на код и гарантира, че формата ще бъде в синхрон с базата данни.
4.2	СЪЗДАВАНЕ НА MODELFORM
За да създадем ModelForm, първо трябва да имаме модел, дефиниран чрез Django ORM. Пример:

/////////

from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=6, decimal_places=2)
    description = models.TextField()
    available = models.BooleanField(default=True)

////////

След това създаваме ModelForm, свързан с този модел:
///////

from django import forms
from .models import Product

class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = ['name', 'price', 'description', 'available']

/////////

Django автоматично ще създаде HTML форма с полетата от модела и ще приложи съответните валидации.

Използване във View
ModelForm се използва по същия начин, както обикновените форми:

//////////

from django.shortcuts import render, redirect
from .forms import ProductForm

def add_product(request):
    if request.method == 'POST':
        form = ProductForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('home')
    else:
        form = ProductForm()
    return render(request, 'add_product.html', {'form': form})

////////////

Методът form.save() автоматично създава или обновява запис в базата данни на базата на въведените стойности.

Полета и конфигурация
ModelForm поддържа следните опции в Meta класа:

model – моделът, към който е свързана формата

fields – списък с полета, които да се включат във формата

exclude – полета, които да се изключат (алтернатива на fields)

labels, widgets, help_texts, error_messages – персонализация на визуализацията

Пример с персонализиране:


/////////////

class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = ['name', 'price']
        labels = {
            'name': 'Име на продукта',
            'price': 'Цена (в лева)'
        }
        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control'}),
            'price': forms.NumberInput(attrs={'step': '0.01'}),
        }

////////////

Предимства на ModelForms
Съкращават кода – автоматично създаване на полета.

Синхронизация с моделите – ако се промени моделът, формата автоматично отразява промените.

Вградена валидация – валидират се типове данни, дължина, уникалност и други ограничения.

Съвместимост със save() – автоматично създаване и запазване на обекти.

Валидация при ModelForms
Както при стандартните форми, можем да добавим допълнителна валидация чрез clean_<field>() или clean() методи.



/////////////


class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = ['name', 'price']

    def clean_price(self):
        price = self.cleaned_data.get('price')
        if price <= 0:
            raise forms.ValidationError('Цената трябва да е положителна стойност.')
        return price
///////////////

Пример от практиката: форма за добавяне на продукт
В контекста на електронен магазин, можем да създадем ModelForm за добавяне на продукти в системата. Това позволява администраторът да въвежда нови продукти чрез уеб интерфейс без нужда от достъп до базата данни директно.

Тази функционалност е част от практическата част на дипломния проект, където се използва ModelForm за динамично добавяне на продукти в клиентската кошница.




Валидиране на данни
Въведение
Валидирането на данни е изключително важна част от всеки уеб проект. То гарантира, че потребителският вход е правилен, логически коректен и безопасен за обработка. Django предлага мощна и гъвкава система за валидация, която може да се прилага както на ниво форма, така и на ниво модел. С помощта на Django Forms и ModelForms, валидирането се извършва автоматично за повечето стандартни типове данни, но също така позволява и създаване на персонализирани правила.

Вградена валидация в Django
Когато се използват стандартни полета от forms.Form или forms.ModelForm, Django автоматично валидира въведените данни според дефинираните типове:

CharField – изисква текст със зададена максимална (и евентуално минимална) дължина.

EmailField – проверява дали въведеното съдържа валиден имейл адрес.

IntegerField – приема само цели числа.

DecimalField – проверява за коректен числов формат с точност.

BooleanField – очаква стойности True/False.

Пример:

//////////

from django import forms

class ContactForm(forms.Form):
    email = forms.EmailField()
    age = forms.IntegerField(min_value=18)

/////////////
Тук автоматично ще бъдат валидирани както имейлът, така и възрастта (минимум 18).

Валидация с метода is_valid()
Основният метод, който се използва за проверка на валидността на форма в Django, е is_valid():

///////////

form = ContactForm(request.POST)
if form.is_valid():
    # обработка на данните
else:
    # форма с грешки

//////////

Когато се извика is_valid(), Django:

Извлича въведените данни;

Изпълнява вградената валидация за всеки тип поле;

Изпълнява всички персонализирани методи за валидация;

Попълва речника form.errors, ако има проблеми.

Персонализирана валидация с clean_<поле>()
За всяко поле може да се създаде метод с име clean_<fieldname>, който позволява допълнителна логика за валидация. Пример:

/////////////////

class RegisterForm(forms.Form):
    username = forms.CharField(min_length=5)

    def clean_username(self):
        value = self.cleaned_data['username']
        if "@" in value:
            raise forms.ValidationError("Потребителското име не може да съдържа '@'.")
        return value

///////////////////
Ако потребителят въведе недопустима стойност, формата ще бъде маркирана като невалидна, а съобщението ще се покаже до съответното поле.

Глобална валидация с clean()
Понякога е необходимо да се сравняват стойности между различни полета. Това се прави в метода clean():

////////////////////////

class PasswordForm(forms.Form):
    password = forms.CharField(widget=forms.PasswordInput)
    confirm = forms.CharField(widget=forms.PasswordInput)

    def clean(self):
        cleaned_data = super().clean()
        p1 = cleaned_data.get("password")
        p2 = cleaned_data.get("confirm")
        if p1 and p2 and p1 != p2:
            raise forms.ValidationError("Паролите не съвпадат.")

//////////////////////

Методът clean() се извиква след всички clean_<поле>() методи.

Валидиране на ModelForms
Когато използваме ModelForm, Django автоматично използва валидаторите, дефинирани в модела. Например:

//////////////////////

class Product(models.Model):
    name = models.CharField(max_length=50)
    price = models.DecimalField(max_digits=6, decimal_places=2, validators=[
        MinValueValidator(0.01)
    ])

////////////


ози валидатор гарантира, че цената не може да бъде по-малка от 0.01. При ModelForm тази проверка ще се извърши автоматично.

Използване на валидатори от django.core.validators
Django предлага голям брой готови валидатори, които могат да се използват в модели и форми:

EmailValidator

RegexValidator

URLValidator

MinValueValidator, MaxValueValidator

validate_slug, validate_email
Пример:
/////////////

from django.core.validators import RegexValidator

class FeedbackForm(forms.Form):
    phone = forms.CharField(validators=[
        RegexValidator(regex=r'^\+359\d{9}$', message='Въведете валиден телефонен номер.')
    ])

/////////////
Съобщения за грешки
Django автоматично показва съобщенията за грешки в шаблона. Те могат да бъдат персонализирани:

//////////////
name = forms.CharField(
    error_messages={'required': 'Името е задължително поле.'}
)
//////////////

В HTML шаблон:

///////////////
{% if form.name.errors %}
  {% for error in form.name.errors %}
    <div class="error">{{ error }}</div>
  {% endfor %}
{% endif %}
//////////////////


Добри практики
Използвай вградени валидатори, когато е възможно.

За прости проверки използвай clean_<поле>().

За зависимости между полета – използвай clean().

Не забравяй да използваш is_valid() преди да достъпваш cleaned_data.

Използвай смислени съобщения за грешки – това подобрява потребителското преживяване.




 Избор на технологии и аргументация
Въведение
В процеса на разработка на уеб приложения изборът на технологии играе ключова роля за успеха на проекта. Той определя не само ефективността на изпълнение, но и лекотата на поддръжка, сигурността, възможността за разширение и интеграция с други системи. В този дипломен проект е реализиран потребителски интерфейс на електронен магазин с помощта на Django – уеб фреймуърк на езика Python, в комбинация с HTML, CSS и Bootstrap за изграждане на визуалната част на приложението.

6.2	АРГУМЕНТАЦИЯ ЗА ИЗБОР НА DJANGO
Django е избран като основна платформа за разработка поради следните причини:
•	Бързо прототипиране и развитие: Django предоставя готови инструменти за управление на потребители, форми, маршрути, администраторски панел и ORM (Object-Relational Mapping), което значително съкращава времето за разработка.
•	Сигурност: Фреймуъркът включва вградена защита срещу често срещани уеб атаки като SQL инжекции, XSS (cross-site scripting), CSRF (cross-site request forgery) и clickjacking. Това е особено важно при работа с чувствителни данни като лична информация и онлайн поръчки.
•	Гъвкава система за форми: Django Forms и ModelForms улесняват създаването на динамични и валидирани форми – основен компонент в електронната търговия.
•	Активна общност и документация: Django е добре документиран, а общността предоставя стотици примери, библиотеки и пакети за допълнителна функционалност.
•	Подходящ за образователни цели: Django е логически структуриран и предлага ясна разделеност между логика, визуализация и данни – което го прави лесен за разбиране и прилагане от ученици и студенти.
6.3	ИЗБОР НА ЕЗИК ЗА ПРОГРАМИРАНЕ: PYTHON
Python е един от най-популярните и четими езици за програмиране. Той е лесен за учене и има широка поддръжка от библиотеки и инструменти. Python се използва активно в образованието, науката, анализа на данни и уеб разработката. Django е създаден именно на Python, което е още една причина за избора на този език за проекта.

6.4	ИЗПОЛЗВАНИ ДОПЪЛНИТЕЛНИ ТЕХНОЛОГИИ
•	HTML и CSS – за изграждане на потребителския интерфейс на формите и страниците.
•	Bootstrap – CSS фреймуърк за по-бързо и лесно създаване на адаптивен и модерен уеб дизайн.
•	SQLite – базата данни по подразбиране в Django, подходяща за малки проекти и демонстрации.
6.5	СРАВНЕНИЕ С АЛТЕРНАТИВНИ ТЕХНОЛОГИИ
В процеса на избор бяха разгледани и други популярни уеб фреймуърци, като Flask, Laravel, Ruby on Rails и ASP.NET. Всеки от тях има своите предимства, но спрямо нуждите на проекта Django се оказа най-подходящ:

Flask е лек Python фреймуърк, който предоставя повече свобода, но изисква ръчно изграждане на множество функционалности – форми, ORM, администраторски панел и др. Това би довело до по-дълъг процес на разработка и по-голяма сложност за ученик в образователен контекст.

Laravel (на PHP) и Ruby on Rails също предлагат добра структура и инструменти, но не са толкова популярни в учебните среди в България, а и изискват усвояване на различен език и среда.

ASP.NET (на C#) е мощен фреймуърк за корпоративни уеб приложения, но се използва предимно в Microsoft среда и има по-висока сложност за начинаещи.

Django, от своя страна, предлага „всичко в едно“ – вграден админ панел, ORM, работа с форми, шаблони, сигурност, и всичко това с минимална нужда от допълнителни настройки.
Образователен аспект на избраните технологии
От гледна точка на обучението и подготовката на бъдещ приложен програмист, работата с Django и Python осигурява силна основа за професионално развитие. Използваните технологии не само отговарят на съвременните пазарни изисквания, но и спомагат за изграждането на ключови умения:

Работа с MVC/MTV архитектура – концепция, приложима и в други езици и фреймуърци.

Работа с бази данни и ORM – основополагащо умение за съвременните програмисти.

Умения за структуриране на проект – чрез разделяне на логика, шаблони, модели и форми.

Разбиране на валидация и сигурност – важни аспекти при всяко реално уеб приложение.

Освен техническите аспекти, ученикът развива и умения за самостоятелна работа, търсене на решения, използване на документация, онлайн ресурси и добри практики – качества, ценени във всяка професионална среда.

Практика, ориентирана към реалността
Избраният проект е не просто учебна задача, а мини версия на реално уеб приложение, каквито се срещат всеки ден в електронната търговия. Това прави работата по него значима и мотивираща, а резултатите – видими и приложими. В процеса на реализация ученикът се докосва до реални казуси:

потребителско взаимодействие с форма;

обработка на POST заявки;

динамично визуализиране на съобщения за грешки;

съхранение на информация в база данни;

генериране на HTML съдържание чрез шаблони;

структуриран код и лесна навигация в проект.
 Анализ на съществуващи решения (други фреймуърци или библиотеки)
 7.1	ВЪВЕДЕНИЕ
В съвременната уеб разработка съществуват множество фреймуърци и библиотеки, които предлагат различни подходи за създаване на динамични форми, обработка на данни и изграждане на потребителски интерфейси. Django е само едно от многото решения, но е важно да се направи сравнителен анализ с други популярни технологии, за да се разберат неговите предимства и ограничения.
7.2	СРАВНЕНИЕ С FLASK (PYTHON)
Flask е друг популярен уеб фреймуърк на Python, който често се сравнява с Django. Основната разлика между тях е в архитектурата и обхвата на функциите:
•	Flask е микрофреймуърк, който предоставя само основната функционалност за уеб сървър, а всичко останало се добавя чрез разширения.
•	Django е пълноценен фреймуърк („всичко в едно“), който включва ORM, система за форми, шаблони, сигурност и админ панел по подразбиране.
От гледна точка на формите:
•	Flask не разполага с вградена система за форми. Обикновено се използва WTForms – отделна библиотека за създаване и валидация на формуляри.
•	Django предлага интегрирана система за форми, която е по-добре документирана и тясно свързана с ORM модела.
Заключение: Flask е подходящ за по-леки и гъвкави проекти, но за учебни и по-структурирани приложения Django е по-ефективен.
7.3	СРАВНЕНИЕ С LARAVEL (PHP)
Laravel е популярен фреймуърк на PHP, който има сходна структура с Django:
•	Поддържа MVC архитектура;
•	Има ORM система (Eloquent);
•	Предоставя Blade шаблони и система за маршрути.
Сравнение с React + Formik / React Hook Form
В по-модерната front-end разработка с JavaScript фреймуърка React, съществуват библиотеки като Formik и React Hook Form, които позволяват лесно изграждане на форми с висока интерактивност.

Предимства: отлична производителност, голяма гъвкавост, подходящи за SPA (Single Page Applications).

Недостатъци: изискват сложна конфигурация, разделят front-end и back-end логиката, което увеличава сложността.

Django, в комбинация с Django Forms, позволява по-лесно изграждане на пълноценна форма с валидиране директно от бекенда, без нужда от отделен front-end фреймуърк.

Алтернативни библиотеки за форми и валидация
Освен WTForms и Formik, съществуват и други библиотеки, в зависимост от езика и средата:

Express-validator (Node.js)

Yup (валидираща библиотека за JavaScript)

Ruby on Rails – Active Record validations

ASP.NET – Data Annotations

Всички те предлагат механизми за валидация, но често изискват допълнителна конфигурация и не са така интегрирани както Django Forms и ModelForms.

Сравнение с React + Formik / React Hook Form
В по-модерната front-end разработка с JavaScript фреймуърка React, съществуват библиотеки като Formik и React Hook Form, които позволяват лесно изграждане на форми с висока интерактивност.

Предимства: отлична производителност, голяма гъвкавост, подходящи за SPA (Single Page Applications).

Недостатъци: изискват сложна конфигурация, разделят front-end и back-end логиката, което увеличава сложността.

Django, в комбинация с Django Forms, позволява по-лесно изграждане на пълноценна форма с валидиране директно от бекенда, без нужда от отделен front-end фреймуърк.

Алтернативни библиотеки за форми и валидация
Освен WTForms и Formik, съществуват и други библиотеки, в зависимост от езика и средата:

Express-validator (Node.js)

Yup (валидираща библиотека за JavaScript)

Ruby on Rails – Active Record validations

ASP.NET – Data Annotations

Всички те предлагат механизми за валидация, но често изискват допълнителна конфигурация и не са така интегрирани както Django Forms и ModelForms.






